---
title: "03-2-1-DEGs-analysis -treatments comparisan (drought vs control)-dropped 2 genotypes"
author: "sepideh.Jafarian"
date: "2024-01-22"
output: 
  rmarkdown::html_document:
    theme: cosmo
    toc: true
    toc_float: true
    toc_depth: 3
    number_sections: TRUE
editor_options: 
  chunk_output_type: inline
   root.dir: "C:/Users/SepidehJafarian/Desktop/BMW-transcriptom-analysis/03-2-1-DEGs-analysis -treatments comparison-dropped"
   
---

```{r, setup, include=TRUE, echo=TRUE, eval=FALSE, warning=FALSE}

knitr::opts_chunk$set(echo = FALSE)
library(DESeq2)
library(tximport)
library(GenomicFeatures)
library(rhdf5)
library(geneplotter)
library(limma)
library(SummarizedExperiment)
library(vsn)
library(pheatmap)
library(RColorBrewer)
library(ggplot2)
library(AnnotationDbi)
library(ggbeeswarm)
library(dplyr)
set.seed(123)
```

```{r, include=TRUE}

require("knitr")
opts_knit$set(root.dir = "C:/Users/SepidehJafarian/Desktop/BMW-transcriptom-analysis/03-2-1-DEGs-analysis -treatments comparison-dropped")
getwd()
```


Set the directory and read the required data

```{r, include=TRUE, echo=TRUE }

wd = "C:/Users/SepidehJafarian/Desktop/BMW-transcriptom-analysis/03-2-1-DEGs-analysis -treatments comparison-dropped"

```


```{r, include=TRUE, echo=TRUE }
#setwd()
setwd(choose.dir())
getwd()

```
##  Accessing the file with
### the counts( resulting from Kallisto, tsv files) without merged lists
### reading the required file(data) 

```{r, include=TRUE, echo=TRUE}
infile <-  file.path(wd,"bmw-samples-info-modified-no group-dropped genotype.csv")
View(infile)
```



```{r, include=TRUE, echo=TRUE}

data = read.table(infile, header=TRUE, sep = ',', stringsAsFactors=FALSE)

View(data)
dim(data)

unique(data$Genotype)
```


## Extracting the data
### including only **filnemes** & **samle names**

```{r, include=TRUE, echo=TRUE}
quant_files <- data[,'FileName']
names(quant_files) <- data[,'SampleName']

head(quant_files)
View(quant_files)

```

## To check all samples and their counts exist
### The results should **TRUE** if all are there

```{r, include=TRUE, echo=TRUE}
all(file.exists(quant_files))
```

## Loading gff3 files which includes the genes information
### We need this file because the transcripts needs to be converted to the genes later on.

```{r, include=TRUE, echo=TRUE}
gtf_file <- "IWGSC_v1.1_HC_20170706.gtf"
file.exists(gtf_file)
```


## database creation
### makeTxDbFromGFF from GenomicFeatures package. This function is specifically designed to create a **transcript database (TxDb) object from a GFF (General Feature Format)** file

```{r, include=TRUE, echo=TRUE, eval=TRUE}
library(GenomicFeatures)
txdb <- makeTxDbFromGFF(gtf_file)

```


## Keytyps
### Finding keytypes and column names of the transcript database (TxDb).We are going to filter the database by a key or set of keys in order to extract the information we want. Valid names for the key can be retrieved with the keytypes function.
#### Select, columns and keys are used together to extract data from an AnnotationDb object
#### The role of the keytypes function is to provide information about the available key types that can be used **to extract metadata or annotations**. This function returns the columns that user can specified in select function.

```{r, include=TRUE, echo=TRUE}
library(GenomicFeatures)
library(AnnotationDbi)
keytypes(txdb)
columns(txdb)
```

## selection
### if we have some keys, we can use select to extract them. By simply using appropriate argument values with select we can specify what keys we want to look up values for (keys), what we want returned back (columns) and the type of keys that we are passing in (keytype).
####  **TXNAME typically refers to the transcript name associated with a genomic feature. It is a label or identifier that represents a specific transcript within a genomic region.**

```{r, include=TRUE, echo=TRUE}

k <- keys(txdb, keytype="TXNAME")
tx_map <- AnnotationDbi::select(txdb, keys = k, columns="GENEID", keytype = "TXNAME")
View(tx_map)
```


```{r, include=TRUE, echo=TRUE}
tx2gene <- tx_map
head(tx2gene)
write.table(tx2gene, file="tx2gene.csv", row.names=FALSE, quote = FALSE)
```

```{r, include=TRUE, echo=TRUE}
View(tx2gene)
```

##  Importind data
### Importing transcript abundance datasets (getting counts from abundance=scaledTPM)
### 1: file= quant_files: a character vector of filenames for the transcript-level abundances
### 2: a two-column data.frame linking transcript id (column 1) to gene id (column 2). the column names are not relevant, but this column order must be used. this argument is required for gene-level summarization, and the tximport vignette describes how to construct this data.frame 

```{r, include=TRUE, echo=TRUE}
library(tximport)
txi <- tximport(quant_files,type="kallisto",tx2gene = tx2gene)
#head(txi)
View(txi$counts)
names(txi)
str(txi)
```
## Tximport < DESeq2
### To get the results from tximport(txi) into DESeq2 (function from tximport package)
### Takes the results of tximport (counts data) 
#### colData which is about the columns in my count data- the way our count data is formatted- (data about the columns in count data (samples)). that is why the sample info needs to be provided at first.
####assigning the column name into rowname

```{r, include=TRUE, echo=TRUE}
sampleinfo <- read.delim(infile, sep=',')
sampleinfo
rownames(sampleinfo) <- sampleinfo$SampleName
head(sampleinfo)
```

```{r, include=TRUE, echo=TRUE}
all(rownames(sampleinfo) == colnames(txi$counts))
```

```{r, include=TRUE, echo=TRUE}

sampleinfo$Genotype<- as.factor(sampleinfo$Genotype)
sampleinfo$Treatment<- as.factor(sampleinfo$Treatment)
#sampleinfo$CID<- as.factor(sampleinfo$CID)
str(sampleinfo)
```
## construct a DESeqDataSet

```{r, include=TRUE, echo=TRUE}
library(DESeq2)
dds<- DESeqDataSetFromTximport(txi, colData=sampleinfo, design= ~0+Treatment)
dds <- estimateSizeFactors(dds)
```

## difference between txi & dds
### counts allows us to extract the count data from dseqdata and will return count matrix (which is the results of tximport)
#### counts from DESeq are rounded wihile deseq works with integer data

```{r, include=TRUE, echo=TRUE}
counts(dds)[1:5, 1:5] # but rounded 
txi$counts[1:5, 1:5] # not rounded
```


```{r, include=TRUE, echo=TRUE}
tpm <- txi$abundance
write.csv(tpm, file="tpm_values.csv",quote=FALSE)

```



## high Variance genes
### Calculation of raw wise variance. It computes the variance of each raw (each gene)
#### selecting only 1000 genes with highest variance ........ (more explanation about these genes in OneNote)


```{r, include=TRUE, echo=TRUE}
topVargenes_dds <- head(       order( rowVars( assay(dds) )
                                      ,decreasing=TRUE )
                        ,1000 )
write.csv(assay(dds[topVargenes_dds,]),file=paste(wd, "normalized_counts_topVar1000.csv", sep='/'))
```


## filtering non-zero counts
### to identify rows (genes or features) in the GeneCounts object that have nonzero counts in **all samples**. It can be useful for filtering out rows with no expression across all samples.
#### Removing the zero counts...based on the factorsize some rows will be returned as zero(due to the geometric mean and reatios)..now wee need to have only non zero ones
#### For this, we make a function:  It takes a vector x (representing each row of GeneCounts) as input and checks if all the values in x are greater than zero using the all() function. The all() function returns TRUE if all the values in x are TRUE; otherwise, it returns FALSE.
#### 1 means for raws. 2 means for columns..here we need raws as genes
##### The variable **idx.nz** will be a logical vector indicating for each gene whether all the counts in that gene's row are greater than zero (TRUE) or not (FALSE).


```{r, include=TRUE, echo=TRUE}

GeneCounts <- counts(dds)
idx.nz <- apply(GeneCounts, 1, function(x) { all(x > 0)})
#idx.nz
sum(idx.nz)
head(GeneCounts[idx.nz, ])
### extracting only none zero elements
nz.counts <- subset(GeneCounts, idx.nz)
```

## Data Visualization {.tabset}

### plot normalized and un-normalized counts in different ways to visualize {.tabset}
#### multiecdf{.tabset}



```{r, include=TRUE, echo=TRUE}
library(geneplotter)

un_mc<-  multiecdf(counts(dds, normalized = F)[idx.nz ,],xlab="mean counts", xlim=c(0, 1000), main="un-normalized counts")
print(un_mc, with=50, height=40, cex.axis=1)


n_mc<-  multiecdf(counts(dds, normalized = T)[idx.nz ,],xlab="mean counts", xlim=c(0, 1000),  main="normalized counts")
print(n_mc, with=50, height=40, cex.axis=1)

```


#### density plot {.tabset}
```{r, include=TRUE, echo=TRUE}
png(file = paste(wd, "before_normalization1.png", sep='/'),width=6,height=6,units="in",res=1200)
multidensity(counts(dds, normalized = F)[idx.nz ,],xlab="mean counts", xlim=c(0, 1000), main="un-normalized counts")
dev.off()
```


```{r, include=TRUE, echo=TRUE}
png(file = paste(wd, "after_normalization1.png", sep='/'),width=6,height=6,units="in",res=1200)
multidensity(counts(dds, normalized = T)[idx.nz ,],xlab="mean counts", xlim=c(0, 1000), main="normalized counts")
dev.off()
```

## low count gees filtration
### While it is not necessary to pre-filter low count genes before running the DESeq2 functions, there are two reasons which make pre-filtering useful: by removing rows in which there are very few reads, we reduce the memory size of the dds data object, and we increase the speed of count modeling within DESeq2. It can also improve visualizations, as features with no information for differential expression are not plotted in dispersion plots or MA-plots. 
#### **to filter out low-count genes that have total counts below a specified threshold (in this case, 10). It helps to focus on genes with higher expression levels for downstream analysis.**

#### selection of the genes with the normalized counts(total counts) more then 10 (treshold)


```{r, include=TRUE, echo=TRUE}
library(limma)
dds <- dds[ rowSums(counts(dds)) > 10, ]

```

## estimate dispersions and plot the main one. **Dispersion**: Variability within the groups


```{r, include=TRUE, echo=TRUE}
dds <- estimateDispersions(dds)
```

```{r, include=TRUE, echo=TRUE}
plotDispEsts(dds)
```

```{r, include=TRUE, echo=TRUE}
png(file = paste(wd, "Dispersion_plot.png", sep='/'),width=6,height=6,units="in",res=1200)
plotDispEsts(dds)
dev.off()
```

###make a colour vector of desired colors

```{r, include=TRUE, echo=TRUE}

statusCol <- c("0h"="#66C2A5", "6h"="#FFD92F","12h"="#8DA0CB", "1d"="#E78AC3", "2d"="#A6D854")

```


## Transformation Explanation:

####### DESeqs "rlog transformation" replaces the VST we had before. It transforms the average of the genes across samples to a log2 scale but "pulls in" those genes for which the evidence for strong fold changes is weak due to low counts. 
#### blind=FALSE means that differences between cell lines and treatment should not add to the variance-mean profile of the experiment. However, the experimental design is not used directly in the transformation, only in estimating the global amount of variability in the counts. ###

```{r, include=TRUE, echo=TRUE}
vsd <- varianceStabilizingTransformation(dds, blind=FALSE)
write.csv(assay(vsd),file=paste(wd, "vsd.csv", sep='/'))
```


```{r, include=TRUE, echo=TRUE}
#par(mar=c(10,4,1,1)+.1)
png(file = paste(wd, " normalized library distribution.png", sep='/'),width=25,height=10,units="in",res=1200)
boxplot(assay(vsd), xlab="", ylab="Log2 counts per million",las=2,main="Normalised Distributions",  col=statusCol)
# Let's add a blue horizontal line that corresponds to the median logCPM
abline(h=median(assay(vsd)), col="blue")
dev.off()

```

## Ordered 1000 High variance genes after the variance stabilizing 

```{r, include=TRUE, echo=TRUE}
topVargenes_dds <- head(order(rowVars(assay(vsd)),decreasing=TRUE),1000)
write.csv(assay(vsd[topVargenes_dds, ]),file=paste(wd, "ordered_vsd_HV_1000.csv", sep='/'))

```


## Highe variance genes ordered

```{r, include=TRUE, echo=TRUE}

topVargenes_dds <- order(rowVars(assay(vsd)),decreasing=TRUE)
write.csv(assay(vsd[topVargenes_dds, ]),file=paste(wd, "ordered_vsd_HV.csv", sep='/'))

```


## Normalization visualization{.tabset}

```{r, include=TRUE, echo=TRUE}
par( mfrow = c( 1, 2 ) )
plot(log2(counts(dds, normalized=TRUE)[,1:2] + 1), pch=16, cex=0.3, main="log2_normalized")
plot(assay(vsd)[,1:2],pch=16, cex=0.3, main="vsd normalized")

```


## to identify rows (genes) that have at least one count greater than zero across all samples.

### compare normalized, counts, rlog transformed counts and vst counts 
###  the purpose of the first command is to identify rows (genes) that have **at least** one count greater than zero across all samples.
### includes genes with ***at least one nonzero count across all samples.***

```{r, include=TRUE, echo=TRUE}
#vsd <- varianceStabilizingTransformation(dds, fitType="local")
notAllZero <- (rowSums(counts(dds))>0)
```


## Visualization {.tabset}

### vsd plot {.tabset}

```{r, include=TRUE, echo=TRUE}
library(vsn)
meanSdPlot(assay(vsd[notAllZero,]))
```


## plot top 20 genes of normalized counts, rlog transformed values and vst values for visualization
```{r, include=TRUE, echo=TRUE}
select <- order(rowMeans(counts(dds,normalized=TRUE)),	decreasing=TRUE)[1:20]

```

```{r, include=TRUE, echo=TRUE}
plotPCA(vsd, intgroup=c("Genotype","Treatment"))
```


```{r, include=TRUE, echo=TRUE}
plotPCA(vsd, intgroup="Treatment")
plotPCA(vsd, intgroup="Genotype")
```

```{r, include=TRUE, echo=TRUE}

df <- as.data.frame(colData(dds)[,c("Genotype","Treatment")])
print(df)
```

### vsd heatmap{.tabset}


```{r, include=TRUE, echo=TRUE}
library(pheatmap)
png(file = paste(wd, "heatmap-vsd-top 20 genes.png", sep='/'),width=25,height=10,units="in",res=1200)
pheatmap(assay(vsd)[select,], cluster_rows=FALSE, show_rownames=FALSE,cluster_cols=FALSE, annotation_col=df)
dev.off()
```

## plot a heatmap of sample distances

```{r, include=TRUE, echo=TRUE}
library(pheatmap)
library(RColorBrewer)
options(repr.plot.width = 39, repr.plot.height = 25 )
sampleDists <- dist(t(assay(vsd)))
sampleDistMatrix <- as.matrix(sampleDists)
rownames(sampleDistMatrix) <- paste(vsd$Treatment, vsd$CID, vsd$Genotype , sep="-")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix, clustering_distance_rows=sampleDists,clustering_distance_cols=sampleDists,col=colors, main="heatmap_samples_distance")
options(repr.plot.width = 12, repr.plot.height = 9, repr.plot.res = 200)
```
### saving the heatmap



```{r, include=TRUE, echo=TRUE}
png(file = paste(wd, "heatmap_samples_distance.png", sep='/'),width=15,height=15,units="in",res=1200)
pheatmap(sampleDistMatrix, clustering_distance_rows=sampleDists,clustering_distance_cols=sampleDists,col=colors)
dev.off()
```

```{r, include=TRUE, echo=TRUE}
options(repr.plot.width = 100, repr.plot.height = 8)

library(dplyr)
library(ggplot2)
cluster_t <- sampleinfo %>%
  mutate(color_Treatment= case_when(Treatment=="control" ~ "green",
                                    Treatment=="stress"~ "red"))
cluster_g <- sampleinfo %>%
  mutate(color_genotype= case_when(Genotype=="BMW_2218" ~ "yellow",
                                    Genotype=="BMW_2007" ~ "grey",
                                    Genotype=="BMW_2267" ~ "darkblue",
                                    Genotype=="BMW_2364" ~ "darkgreen",
                                    Genotype=="BMW_2496" ~ "orange",
                                    Genotype=="BMW_2156" ~ "salmon",
                                    Genotype=="BMW_2095" ~ "brown",
                                    Genotype=="BMW_2352" ~ "magenta",
                                    Genotype=="BMW_2321" ~ "pink",
                                    Genotype=="BMW_2297" ~ "purple"))

#cluster_CID <- sampleinfo %>%
  #mutate(color_CID= case_when(CID=="High" ~ "black",
                                 # CID=="Low"~ "grey"))



library(dendextend)
png(file = paste(wd, "hierarchical clustering.png", sep='/'),width=20,height=10,units="in",res=1200)
par(mar=c(10,6,2,10))
sampleTree = as.dendrogram(hclust(sampleDists, method = "complete"));

sampleTree %>%
  set("leaves_pch", 10)%>%
  set("labels_cex", 1)%>%
  set("branches_lwd",3)%>%
  color_branches(k=10) %>%
#png(file = paste(wd, "clustering_labled.png", sep='/'),width=15,height=15,units="in",res=1200)
plot( main="samples clustering")


cluster_t<- cluster_t$color_Treatment
cluster_g <- cluster_g$color_genotype
#cluster_CID<- cluster_CID$color_CID
both_bars<- cbind(cluster_t, cluster_g)
colored_bars(colors = both_bars , dend=sampleTree , rowLabels=c("Treatment","Genotype"))

legend(aes(x=60,y=305 ),
legend=c("Control", "Stress" ),
col=c("green", "red"),
pch=c(20,20,20,20), bty="b", pt.cex=1.5, cex=0.8,
text.col= "black", horiz=TRUE, inset=c(1,1))


legend(aes(x=7,y=305 ),
legend=c( "BMW_2218","BMW_2007","BMW_2267","BMW_2364","BMW_2496","BMW_2156","BMW_2095","BMW_2352","BMW_2321","BMW_2297"),
col=c("yellow","grey","darkblue", "darkgreen", "orange", "salmon", "brown", "magenta", "pink", "purple"),
pch=c(20,20,20,20), bty="b", pt.cex=1.5, cex=0.8,
text.col= "black", horiz=TRUE, inset=c(1,1))
dev.off()
```


## PCA 
### plot pca with each sample in different color

```{r, include=TRUE, echo=TRUE}
pcaData <- plotPCA(vsd, intgroup = c("Treatment", "Genotype"), returnData=TRUE, ntop=48370)
percentVar <- round(100 * attr(pcaData, "percentVar"))
```

```{r, include=TRUE, echo=TRUE}
sample_names<- pcaData$name
sample_names<- gsub("BMW_", "", sample_names)
sample_names
class(sample_names)
```

```{r, include=TRUE, echo=TRUE}

library(ggplot2)
#options(repr.plot.width = 20, repr.plot.height = 9, repr.plot.res = 200)
# Specify shape values for each unique level in Genotype
png(file=paste(wd, "PCA-all factors.png", sep='/') ,width=15,height=10,units="in",res=1200)
shape_values <- c(22, 23, 24, 21, 25, 21, 25.5, 22.5, 23.5, 24.8)

pca_plot<- ggplot(pcaData, aes(PC1, PC2, shape =Genotype, color = Genotype, fill = Treatment)) +
  geom_point(size = 3, stroke = 1, position = position_jitter(h = 0.5, w = 0.5), alpha = 0.8) +
  scale_fill_manual(values = c("stress" = "red", "control" = "black")) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  scale_shape_manual(values = shape_values) +
  guides(fill = guide_legend(override.aes = list(shape = 21))) +
  coord_fixed()
pca_plot
#pca_plot + geom_text(aes(label = sample_names), size=2.5 ,nudge_x = 0.05, nudge_y = 0.5)
dev.off()
```





```{r, include=TRUE, echo=TRUE}

library(ggplot2)
#options(repr.plot.width = 20, repr.plot.height = 9, repr.plot.res = 200)
# Specify shape values for each unique level in Genotype

shape_values <- c(22, 23, 24, 21, 25, 21, 25.5, 22.5, 23.5, 24.8)

pca_plot<- ggplot(pcaData, aes(PC1, PC2, shape =Genotype, color = Genotype, fill = Treatment)) +
  geom_point(size = 3, stroke = 1, position = position_jitter(h = 0.5, w = 0.5), alpha = 0.8) +
  scale_fill_manual(values = c("stress" = "red", "control" = "black")) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  scale_shape_manual(values = shape_values) +
  guides(fill = guide_legend(override.aes = list(shape = 21))) +
  coord_fixed()
#pca_plot
pca_plot + geom_text(aes(label = sample_names), size=2.5 ,nudge_x = 0.05, nudge_y = 0.5)

```



```{r, include=TRUE, echo=TRUE}
png(file=paste(wd, "PCA-labled.png", sep='/') ,width=15,height=10,units="in",res=1200)	
library(ggplot2)
#options(repr.plot.width = 20, repr.plot.height = 9, repr.plot.res = 200)
# Specify shape values for each unique level in Genotype
#shape_values <- c(22, 23, 24, 21, 25, 21, 25.5, 22.5, 23.5, 24.8)


pca_plot<- ggplot(pcaData, aes(PC1, PC2, shape =Genotype, color = Genotype, fill = Treatment)) +
  geom_point(size = 3, stroke = 1, position = position_jitter(h = 0.5, w = 0.5), alpha = 0.8) +
  scale_fill_manual(values = c("stress" = "red", "control" = "black")) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  scale_shape_manual(values = shape_values) +
  guides(fill = guide_legend(override.aes = list(shape = 21))) +
  coord_fixed()
#pca_plot
pca_plot + geom_text(aes(label = sample_names), size=2.5 ,nudge_x = 0.05, nudge_y = 0.5)
dev.off()
```

```{r, include=TRUE, echo=TRUE}
png(file=paste(wd, "PCA.png", sep='/') ,width=15,height=10,units="in",res=1200)	
library(ggplot2)
#options(repr.plot.width = 20, repr.plot.height = 9, repr.plot.res = 200)
# Specify shape values for each unique level in Genotype
#shape_values <- c(22, 23, 24, 21, 25, 21, 25.5, 22.5, 23.5, 24.8)


pca_plot<- ggplot(pcaData, aes(PC1, PC2, shape =Genotype, color = Genotype, fill = Treatment)) +
  geom_point(size = 3, stroke = 1, position = position_jitter(h = 0.5, w = 0.5), alpha = 0.8) +
  scale_fill_manual(values = c("stress" = "red", "control" = "black")) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  scale_shape_manual(values = shape_values) +
  guides(fill = guide_legend(override.aes = list(shape = 21))) +
  coord_fixed()
pca_plot
dev.off()
```

#```{r, include=TRUE, echo=TRUE}

pcaData1 <- plotPCA(vsd, intgroup = c("Treatment", "CID", "Genotype"), returnData=TRUE, ntop=48370)
percentVar1 <- round(100 * attr(pcaData1, "percentVar"))

png(file=paste(wd, "PCA-labled-all factors.png", sep='/') ,width=15,height=10,units="in",res=1200)	
library(ggplot2)
#options(repr.plot.width = 20, repr.plot.height = 9, repr.plot.res = 200)
# Specify shape values for each unique level in Genotype
shape_values <- c(22, 23, 24, 21, 25, 21, 25.5, 22.5, 23.5, 24.8)


pca_plot<- ggplot(pcaData1, aes(PC1, PC2, shape =CID, color = Genotype, fill = Treatment)) +
  geom_point(size = 3, stroke = 1, position = position_jitter(h = 0.5, w = 0.5), alpha = 0.8) +
  scale_fill_manual(values = c("stress" = "red", "control" = "black")) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  scale_shape_manual(values = shape_values) +
  guides(fill = guide_legend(override.aes = list(shape = 21))) +
  coord_fixed()
#pca_plot
pca_plot + geom_text(aes(label = sample_names), size=2.5 ,nudge_x = 0.05, nudge_y = 0.5)
dev.off()
#```

#```{r, include=TRUE, echo=TRUE}
library(ggplot2)
library(plotly)

# Specify shape values for each unique level in Genotype
shape_values <- c(22, 23, 24, 21, 25, 21, 25.5, 22.5, 23.5, 24.8)

# Create the ggplot object
p <- ggplot(pcaData, aes(PC1, PC2, shape = CID, color = CID, fill = Treatment)) +
  geom_point(size = 3, stroke = 1, position = position_jitter(h = 0.5, w = 0.5), alpha = 0.8) +
  scale_fill_manual(values = c("stress" = "red", "control" = "black")) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  scale_shape_manual(values = shape_values) +
  guides(fill = guide_legend(override.aes = list(shape = 21))) +
  coord_fixed()

# Convert the ggplot object to a plotly object
p_plotly <- ggplotly(p)

# Display the interactive plot
p_plotly
#```

## *differential expression analysis*

```{r, include=TRUE, echo=TRUE}
library(DESeq2)
dds <- DESeq(dds)
```

```{r, include=TRUE, echo=TRUE}

resultsNames(dds)
```
## using the method froom maxim and needs to be like this to get the contrasts while we added 0 in our model not to have the intercept
```{r, include=TRUE, echo=TRUE}

resultsNames(dds)
```
## build results

```{r, include=TRUE, echo=TRUE}
res <- results(dds, contrast =c("Treatment", "stress", "control" ))
res

```




```{r, include=TRUE, echo=TRUE}
any(is.na(row.names(res)))
any(is.na(row.names(res)))

``` 


##	build results for significant genes of the candidate genes showing a differential expression in VB in comparison to GfGa
```{r, include=TRUE, echo=TRUE}
library("AnnotationDbi")
res$CHROM <- mapIds(txdb,keys=row.names(res),column="CDSCHROM", keytype="GENEID", multiVals="first")
res$CDSNAME <- mapIds(txdb,keys=row.names(res),column="CDSNAME", keytype="GENEID", multiVals="first")
res$CDSSTART <- mapIds(txdb,keys=row.names(res),column="CDSSTART", keytype="GENEID", multiVals="first")
res$CDSEND <- mapIds(txdb,keys=row.names(res),column="CDSEND", keytype="GENEID", multiVals="first")
res$CDSSTRAND <- mapIds(txdb,keys=row.names(res),column="CDSSTRAND", keytype="GENEID", multiVals="first")
res$symbol <- mcols(res)$symbol
```


## Exporting only the results which pass an adjusted p value threshold 0.05

```{r, include=TRUE, echo=TRUE}
resSig <- subset(res, padj < 0.05)#extract subset
resSig <- as.data.frame(resSig)#build a data frame from subset to write it out
write.csv(resSig,  file=paste(wd, "results_sig_pvalue less 0.05.csv", sep='/'))
```

```{r, include=TRUE, echo=TRUE}
resSig1 <- subset(res, padj <= 0.05)#extract subset
resSig1 <- as.data.frame(resSig1)#build a data frame from subset to write it out
write.csv(resSig1,  file=paste(wd, "results_sig_pvalue equal_less 0.05.csv", sep='/'))
```

## up regulated and downregulated genes
```{r, include=TRUE, echo=TRUE}
up <- subset(res, padj <= 0.05& log2FoldChange > 1)
write.csv(up,  file=paste(wd, "results_stress_vs_control_0.05padj_log2fc1_up.csv", sep='/'))

```


```{r, include=TRUE, echo=TRUE}

down <- subset(res, padj <= 0.05 & log2FoldChange < -1)
write.csv(down,  file=paste(wd, "results_stress_vs_control_0.05padj_log2fc1_down.csv", sep='/'))

```




## Plotting results

```{r, include=TRUE, echo=TRUE}
png(file=paste(wd, "MA_plot.png", sep='/') ,width=20,height=10,units="in",res=1200)
#fig.show='hold'
DESeq2::plotMA(res)
dev.off()

```

```{r, include=TRUE, echo=TRUE}
hist(res$pvalue[res$baseMean > 1], breaks=0:20/20, col="grey50", border="white")
```


## genes with the most variation of counts:
```{r, include=TRUE, echo=TRUE}
topVarGenes <- head(order(rowVars(assay(vsd)),decreasing=TRUE),30)
```




### genes with padj < 0.05:
### 30 top genes

```{r, include=TRUE, echo=TRUE}
resOrdered <- res[order(res$padj,decreasing=FALSE),]#order genes by padj
selected_genes<-rownames(subset(resOrdered, padj < 0.05))[1:30]

```



#heatmap of differentially expressed genes:

```{r, include=TRUE, echo=TRUE}
mat <- assay(vsd)[ selected_genes, ]
mat <- mat - rowMeans(mat)
```

```{r, include=TRUE, echo=TRUE}
thr <- 2 
mat[mat < -thr] <- -thr
mat[mat > thr] <- thr
df <- as.data.frame(colData(vsd)[, c("Genotype", "Treatment")])
rownames(df) <- colnames(mat)
#df$CID <- factor(df$CID)
df$Treatment <- factor(df$Treatment)
```

```{r, include=TRUE, echo=TRUE}
annotation_colors <- list(
        Treatment = c(control = "black", stress = "red"))
  #CID=c(High="blue", Low="orange")

```

```{r, include=TRUE, echo=TRUE}
options(repr.plot.width = 25, repr.plot.height = 15, repr.plot.res = 200)
breaks=seq(from=-thr, to=thr, length=101)
pheatmap(mat, annotation_col=df,cluster_col=TRUE, cluster_rows = TRUE, annotation_colors=annotation_colors, fontsize = 10)
```

```{r, include=TRUE, echo=TRUE}
png(file=paste(wd, "heatmap_selected_DEG_30 top genes.png", sep='/') ,width=20,height=10,units="in",res=1200)	
breaks=seq(from=-thr, to=thr, length=101)
pheatmap(mat, annotation_col=df,cluster_col=TRUE, cluster_rows = TRUE, annotation_colors=annotation_colors)
dev.off()
```


